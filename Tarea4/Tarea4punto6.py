# -*- coding: utf-8 -*-
"""Untitled12.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QsXv1vDQp5uNx0_MWy706NrpoVAjf6E6
"""

import numpy as np
import matplotlib.pyplot as plt

def potential(x):
    return 0.5 * x**2

def numerov_method(x_values, energy, psi_x0=0.0, psi_x1=1e-5):
    dx = x_values[1] - x_values[0]
    k_squared = 2.0 * (energy - potential(x_values))

    psi = np.zeros_like(x_values)
    psi[0] = psi_x0
    psi[1] = psi_x1

    for i in range(2, len(x_values)):
        psi[i] = ((2 * (1 - 5 * (dx ** 2) / 12 * k_squared[i - 1]) * psi[i - 1] - (1 + (dx ** 2) / 12 * k_squared[i - 2]) * psi[i - 2]) / (1 + (dx ** 2) / 12 * k_squared[i]))

    normalization = np.trapz(psi**2, x_values)
    psi /= np.sqrt(normalization)

    return psi

x_min = -5.0
x_max = 5.0
num_points = 1000
x_values = np.linspace(x_min, x_max, num_points)
plt.figure(figsize=(10, 6))
for n in range(6):
    energy = (n + 0.5)
    psi_numerov = numerov_method(x_values, energy)
    plt.plot(x_values, psi_numerov, label=f'Energía n={n}')

plt.title('Funciones de onda para los primeros seis niveles de energía usando el método de Numerov')
plt.xlabel('Posición')
plt.ylabel('Función de onda')
plt.grid(True)
plt.legend()
plt.show()

# Potencial gaussiano
def potential_gaussian(x):
    return -10 * np.exp(-x**2 / 20.0)

def diagonalize_hamiltonian_gaussian(x_values, num_states):
    num_points = len(x_values)
    dx = x_values[1] - x_values[0]
    diag = np.diag(potential_gaussian(x_values))
    off_diag = np.diag(-0.5 / dx**2 * np.ones(num_points - 1), k=1) + np.diag(-0.5 / dx**2 * np.ones(num_points - 1), k=-1)
    hamiltonian = diag + off_diag
    eigenvalues, eigenvectors = np.linalg.eigh(hamiltonian)
    return eigenvalues[:num_states], eigenvectors[:, :num_states]

# Potencial racional
def potential_rational(x):
    return -4 / (1 + x**2)**2

def numerov_method(x_values, energy, psi_x0=0.0, psi_x1=1e-5):
    dx = x_values[1] - x_values[0]
    k_squared = 2.0 * (energy - potential_rational(x_values))

    psi = np.zeros_like(x_values)
    psi[0] = psi_x0
    psi[1] = psi_x1

    for i in range(2, len(x_values)):
        psi[i] = ((2 * (1 - 5 * (dx ** 2) / 12 * k_squared[i - 1]) * psi[i - 1] - (1 + (dx ** 2) / 12 * k_squared[i - 2]) * psi[i - 2]) / (1 + (dx ** 2) / 12 * k_squared[i]))

    normalization = np.trapz(psi**2, x_values)
    psi /= np.sqrt(normalization)

    return psi

# Rango espacial para el potencial racional
x_min_rational = -10.0
x_max_rational = 10.0
num_points_rational = 1000
x_values_rational = np.linspace(x_min_rational, x_max_rational, num_points_rational)

# Calcular y graficar los primeros cinco estados ligados para el potencial gaussiano
num_states_gaussian = 5
x_min_gaussian = -5.0
x_max_gaussian = 5.0
num_points_gaussian = 1000
x_values_gaussian = np.linspace(x_min_gaussian, x_max_gaussian, num_points_gaussian)
eigenvalues_gaussian, eigenvectors_gaussian = diagonalize_hamiltonian_gaussian(x_values_gaussian, num_states_gaussian)

print("Energías de los primeros cinco estados ligados para el potencial gaussiano:")
print(eigenvalues_gaussian)

plt.figure(figsize=(10, 6))
for i in range(num_states_gaussian):
    wavefunction = eigenvectors_gaussian[:, i]
    plt.plot(x_values_gaussian, wavefunction, label=f'Energía n={i}')

plt.title('Primeros cinco estados ligados para el potencial gaussiano')
plt.xlabel('Posición')
plt.ylabel('Función de onda')
plt.legend()
plt.grid(True)
plt.show()

# Calcular y graficar los dos estados ligados para el potencial racional
plt.figure(figsize=(10, 6))
for i, energy in enumerate([-1.478, -0.163]):
    psi_rational = numerov_method(x_values_rational, energy)
    plt.plot(x_values_rational, psi_rational, label=f'Energía n={i}')

plt.title('Dos estados ligados para el potencial racional usando el método de Numerov')
plt.xlabel('Posición')
plt.ylabel('Función de onda')
plt.legend()
plt.grid(True)
plt.show()